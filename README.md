# free shell

#### ბრძანებების გაშვება

როგორც კი შემოვა ახალი ინფუთი იუზერისგან მაშინვე გადავცემთ parse() მეთოდს, სადაც ვშლით ქომანდებად get_commands მეთოდის გამოყენებით.
მაგალითად თუ შემოვიდა: 
```
command1 || command2 && command3 ; command4
```
ჩვენ დავშლით და მივიღებთ char** ტიპის ობიექტს სადაც არის შენახულია 
```
[command1, | , command2, && , command3, ; , command4]
```
გადავუყვებით არაის და თუ არაის წევრი არის | ან & მაშინ ვამოწმებთ წინა command მა რა სტატუსი დააბრუნა და მაგის მიხედვით ვაკეთებთ შემდეგ
commands ს ხოლო თუ ; იმე შემოვიდა მაშინ უბრალოდ ვაგრძელებთ ციკლს.

თუ command ზე ვართ, მაშინ ვიძახებთ remove_white_space მეთოდს და შემოსულ ქომანდს ვშლით სადაც პირველი წევრი უნდა იყოს ბრძანება
დანარჩენი კი არგუმენტები. მაგალითად თუ command არის:
```
ls -l
```
ჩვენ მივიღებთ char** ტიპის ობიექტს სადაც წერია:
```
[ls, -l]
```
ახლა კი ვამოწმებთ, თუ ბრძანება ბილთინია მაშინ პირდაპირ ვიძახებთ შესაბამის მეთოდს, თუ არა მაშინ არაიში ვეძებთ " | " სიმბოლოს და თუ 
ვიპოვეთ მაშინ საქმე გვაქვს ე.წ. pipeline თან და ვიძახებთ ამავე სახელწედების მეთოდს, სხვა შემთხვევაში კი run_program მეთოდს რომელიც შემოსულ
ბრძანებას დააექსექიუთებს.

იმ შემთხვევაში თუ pipeline არის, მაშინ პირველ რიგში ვნახულობთ თუ რამდენი ქომანდია. ამას ვაკეთებთ ' | ' რაოდენობას + 1. დასაწყისში ვქმნით
ორ პაიპს, და გადავუყვებით ყველა ქომანდს. იმის მიხედვით თუ რომელ ადგილზეა ქომანდი, ვხსნით შესაბამისი პაიპის შესაბამის ბოლოს. შეიძლება
ითქვას, ორ პაიპში ჯვარედინად ვცლით ინფორმაციას. ვეითს ვიყენებთ მხოლოდ ბოლო პროცესისთვის, რადგან არ გვინდა რომ ქომანდები ერთმანეთს
დაელოდონ (disclaimer: დაგუგვლის შედეგად, გავარკვიე რომ პაიპში ყველა ქომანდი პარალელურად ეშვება და წინას მხოლოდ ინფუთის დროს
ელოდება ამიტომ მივიღე ეს გადაწყვეტილება), ვინახავთ ყველა პროცესის id ს და ბოლოს ვავეითებთ ყველას.

#### file I/O

ქომანდის გაშვების წინ, ვამოწმბთ ინფუთ აუთფუთ ფაილი ხომ არ გვჭირდება. ამისთვის ვიყენებთ get_IO მეთოდს რომელიც გვიბრუნებს ინტს
თუ რა უნდა ვქნათ: წავიკითხოთ, ჩავწეროთ, ორივე ერთად, ჩავწეროთ ფაილის განულების გარეშე თუ ჩავწეროთ განულების გარეშე და წავიკითხოთ.

იმის მიხედვით თუ რას დაგვიბრუნებს ზემოთ თქმული მეთოდი "ვdupავთ" შესაბამის ფაილ დისკრიპტორებს, და შემდეგ ვიძახებს სისტემ ქოლს
პროგრამის გასაშვებად. ამის ასევე ვაკეთებთ pipeline ში.
